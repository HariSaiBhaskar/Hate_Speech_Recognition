# -*- coding: utf-8 -*-
"""Hate speech recognition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CmgNxh0eDCc4b_ySCYahlxl-urlAuBMP

IMPORTING LIBRARIES AND LOADING DATASET
"""

import pandas as pd
import re
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import label_binarize

# Load the dataset
dataset_path = 'test.csv'
df = pd.read_csv(dataset_path)

# Display the first few rows to verify
print(df.head())

"""**Text preprocessing function**"""

def preprocess_text(text):
    text = text.lower()  # Lowercase text
    text = re.sub(r'\d+', '', text)  # Remove digits
    text = re.sub(r'\W+', ' ', text)  # Remove non-word characters
    text = text.strip()  # Remove leading and trailing whitespace
    return text
    df['Tweet'] = df['Tweet'].apply(preprocess_text)

"""**Split the dataset into features and target**"""

X = df['Tweet']
y = df['Class']

"""**Binarize the output for multi-class ROC**"""

y_binarized = label_binarize(y, classes=['normal', 'hate', 'abusive'])
n_classes = y_binarized.shape[1]

# Split the dataset into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y_binarized, test_size=0.2, random_state=42)

# Feature extraction using TF-IDF
vectorizer = TfidfVectorizer(max_features=5000)
X_train_tfidf = vectorizer.fit_transform(X_train)
X_test_tfidf = vectorizer.transform(X_test)

"""**Model Training**"""

from sklearn.linear_model import LogisticRegression
from sklearn.multiclass import OneVsRestClassifier

# Train a classification model (Logistic Regression with One-vs-Rest)
model = OneVsRestClassifier(LogisticRegression())
model.fit(X_train_tfidf, y_train)

"""**Model Evaluation**"""

from sklearn.metrics import classification_report, accuracy_score, confusion_matrix, roc_curve, auc
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# Make predictions on the test set
y_pred = model.predict(X_test_tfidf)

# Evaluate the model
print('Accuracy:', accuracy_score(y_test, y_pred))
print(classification_report(y_test, y_pred, target_names=['normal', 'hate', 'abusive']))

# Generate the confusion matrix
conf_matrix = confusion_matrix(y_test.argmax(axis=1), y_pred.argmax(axis=1))

# Plot the heatmap for the confusion matrix
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['normal', 'hate', 'abusive'], yticklabels=['normal', 'hate', 'abusive'])
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()

# Compute ROC curve and ROC area for each class
fpr = dict()
tpr = dict()
roc_auc = dict()
for i in range(n_classes):
    fpr[i], tpr[i], _ = roc_curve(y_test[:, i], model.decision_function(X_test_tfidf)[:, i])
    roc_auc[i] = auc(fpr[i], tpr[i])

# Plot all ROC curves
plt.figure(figsize=(10, 8))
colors = ['blue', 'green', 'red']
for i, color in enumerate(colors):
    plt.plot(fpr[i], tpr[i], color=color, lw=2, label='ROC curve of class {0} (area = {1:0.2f})'.format(i, roc_auc[i]))
plt.plot([0, 1], [0, 1], color='gray', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) Curves')
plt.legend(loc="lower right")
plt.show()